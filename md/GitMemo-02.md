# Git Memo [26/08/2022] #

## 2.1 Основы Git - Создание Git-репозитория ##

### Создание репозитория в существующем каталоге ###

```bash
git init
```

### Клонирование существующего репозитория ###

```bash
git clone https://github.com/libgit2/libgit2
git clone git://
git clone user@server:path/to/repo.git
```

## 2.2 Основы Git - Запись изменений в репозиторий ##

### Определение состояния файлов ###

```bash
git status
```

### Сокращенный вывод статуса ###

```bash
git status -s
```
или

```bash
git status --short
```

### Игнорирование файлов ###

К шаблонам в файле *.gitignore* применяются следующие правила:

- пустые строки, а также строки, начинающиеся с `#`, игнорируются.
- стандартные шаблоны являются глобальными и применяются рекурсивно для всего дерева каталогов.
- чтобы избежать рекурсии используйте символ слеш `/` в начале шаблона.
- чтобы исключить каталог добавьте слеш `/` в конец шаблона.
- можно инвертировать шаблон, использовав восклицательный знак `!` в качестве первого символа.

Glob-шаблоны представляют собой упрощённые регулярные выражения, используемые командными интерпретаторами.
- символ `*` соответствует 0 или более символам;
- последовательность `[abc]` — любому символу из указанных в скобках (в данном примере a, b или c);
- знак вопроса `?` соответствует одному символу;
- квадратные скобки, в которые заключены символы, разделённые дефисом `[0-9]`, соответствуют любому символу из интервала (в данном случае от 0 до 9).
- Вы также можете использовать две звёздочки, чтобы указать на вложенные каталоги: `a/**/z` соответствует a/z, a/b/z, a/b/c/z, и так далее.
___
GitHub поддерживает довольно полный список примеров *.gitignore* файлов для множества проектов и языков https://github.com/github/gitignore это может стать отправной точкой для *.gitignore* в вашем проекте.

### Просмотр индексированных и неиндексированных изменений ###

Позже мы рассмотрим команду `git diff` подробнее; вы, скорее всего, будете использовать эту команду для получения ответов на два вопроса: что вы изменили, но ещё не проиндексировали, и что вы проиндексировали и собираетесь включить в коммит.

Чтобы увидеть, что же вы изменили, но пока не проиндексировали, наберите

```bash
git diff
```

без аргументов. Эта команда сравнивает содержимое вашего рабочего каталога с содержимым индекса. Результат показывает ещё не проиндексированные изменения.

Если вы хотите посмотреть, что вы проиндексировали и что войдёт в следующий коммит, вы можете выполнить

```bash
git diff --staged
```
Эта команда сравнивает ваши проиндексированные изменения с последним коммитом.

Важно отметить, что `git diff` сама по себе не показывает все изменения сделанные с последнего коммита—только те, что ещё не проиндексированы. Такое поведение может сбивать с толку, так как если вы проиндексируете все свои изменения, то `git diff` ничего не вернёт.

Используйте `git diff` для просмотра непроиндексированных изменений, а так же `git diff --cached` для просмотра проиндексированных изменений (`--staged` и `--cached` синонимы).

#### Git Diff во внешних инструментах ####

Мы будем продолжать использовать команду `git diff` различными способами на протяжении всей книги. Существует еще один способ просматривать эти изменения, если вы предпочитаете графический просмотр или внешнюю программу просмотра различий, вместо консоли. Выполнив команду `git difftool` вместо `git diff`, вы сможете просмотреть изменения в файле с помощью таких программ как emerge, vimdiff и других (включая коммерческие продукты). Выполните `git difftool --tool-help` чтобы увидеть какие из них уже установлены в вашей системе.

### Коммит изменений ###

```bash
git commit
```

Эта команда откроет выбранный вами текстовый редактор. Комментарий по умолчанию для коммита содержит закомментированный результат работы команды git status и ещё одну пустую строку сверху.

#### Примечание ####

Для ещё более подробного напоминания, что же именно вы поменяли, можете передать аргумент `-v` в команду `git commit`. Это приведёт к тому, что в комментарий будет также помещена дельта/diff изменений.

Вы можете набрать свой комментарий к коммиту в командной строке вместе с командой `commit` указав его после параметра `-m`:

```bash
git commit -m "Story 182: fix benchmarks for speed"
```
### Игнорирование индексации ###

Несмотря на то, что индекс может быть удивительно полезным для создания коммитов именно такими, как вам и хотелось, он временами несколько сложнее, чем вам нужно в процессе работы. Если у вас есть желание пропустить этап индексирования, Git предоставляет простой способ. Добавление параметра `-a` в команду `git commit` заставляет Git автоматически индексировать каждый уже отслеживаемый на момент коммита файл, позволяя вам обойтись без `git add`.

### Удаление файлов ###

Для того чтобы удалить файл из Git, вам необходимо удалить его из отслеживаемых файлов (точнее, удалить его из вашего индекса) а затем выполнить коммит. Это позволяет сделать команда `git rm`, которая также удаляет файл из вашего рабочего каталога, так что в следующий раз вы не увидите его как «неотслеживаемый».

Если вы просто удалите файл из своего рабочего каталога, он будет показан в секции *«Changes not staged for commit»* (измененные, но не проиндексированные) вывода команды `git status`.

Затем, если вы выполните команду `git rm`, удаление файла попадёт в индекс. После следующего коммита файл исчезнет и больше не будет отслеживаться.

Если вы изменили файл и уже проиндексировали его, вы должны использовать принудительное удаление с помощью параметра `-f`. Это сделано для повышения безопасности, чтобы предотвратить ошибочное удаление данных, которые ещё не были записаны в снимок состояния и которые нельзя восстановить из Git.

Другая полезная штука, которую вы можете захотеть сделать — это удалить файл из индекса, оставив его при этом в рабочем каталоге. Другими словами, вы можете захотеть оставить файл на жёстком диске, но перестать отслеживать изменения в нём. Это особенно полезно, если вы забыли добавить что-то в файл *.gitignore* и по ошибке проиндексировали, например, большой файл с логами, или кучу промежуточных файлов компиляции. Чтобы сделать это, используйте опцию `--cached`.

В команду `git rm` можно передавать файлы, каталоги или шаблоны.

### Перемещение файлов ###

```bash
git mv <file_from> <file_to>
```

Git неявно определяет, что произошло переименование, поэтому неважно, переименуете вы файл так или используя команду `mv`. Единственное отличие состоит лишь в том, что `mv` — одна команда вместо трёх — это функция для удобства. Важнее другое — вы можете использовать любой удобный способ для переименования файла, а затем воспользоваться командами `add` или `rm` перед коммитом.

## 2.3 Основы Git - Просмотр истории коммитов ##

### Просмотр истории коммитов ###

```bash
git log
```

По умолчанию (без аргументов) `git log` перечисляет коммиты, сделанные в репозитории в обратном к хронологическому порядке — последние коммиты находятся вверху. Команда `git log` имеет очень большое количество опций для поиска коммитов по разным критериям. Рассмотрим наиболее популярные из них.

Одним из самых полезных аргументов является `-p` или `--patch`, который показывает разницу (выводит патч), внесенную в каждый коммит. Так же вы можете ограничить количество записей в выводе команды; используйте параметр `-2` для вывода только двух записей.

```bash
git log -p -2
```

Так же есть возможность использовать серию опций для обобщения. Например, если вы хотите увидеть сокращенную статистику для каждого коммита, вы можете использовать опцию `--stat`.

```bash
git log --stat
```

Опция `--stat` печатает под каждым из коммитов список и количество измененных файлов, а также сколько строк в каждом из файлов было добавлено и удалено. В конце можно увидеть суммарную таблицу изменений.

Следующей действительно полезной опцией является `--pretty`. Эта опция меняет формат вывода. Существует несколько встроенных вариантов отображения. Опция `oneline` выводит каждый коммит в одну строку, что может быть очень удобным если вы просматриваете большое количество коммитов. К тому же, опции `short`, `full` и `fuller` делают вывод приблизительно в том же формате, но с меньшим или большим количеством информации соответственно.

```bash
git log --pretty=oneline
```

Наиболее интересной опцией является format, которая позволяет указать формат для вывода информации. Особенно это может быть полезным когда вы хотите сгенерировать вывод для автоматического анализа — так как вы указываете формат явно, он не будет изменен даже после обновления Git.

```bash
git log --pretty=format:"%h - %an, %ar : %s"
```

Полезные опции для `git log --pretty=format` отображает наиболее полезные опции для изменения формата.


**Таблица 1.** Полезные опции для `git log --pretty=format`


| Опция | Описания вывода |
|-------|-----------------|  
| %H | Хеш коммита |
| %h | Сокращенный хеш коммита |
| %T | Хеш дерева |
| %t | Сокращенный хеш дерева |
| %P | Хеш родителей |
| %p | Сокращенный хеш родителей |
| %an | Имя автора |
| %ae | Электронная почта автора |
| %ad | Дата автора<br>(формат даты можно задать опцией --date=option) |
| %ar | Относительная дата автора |
| %cn | Имя коммитера |
| %ce | Электронная почта коммитера |
| %cd | Дата коммитера |
| %cr | Относительная дата коммитера |
| %s | Содержание |

*Автор* — это человек, изначально сделавший работу, а *коммитер* — это человек, который последним применил эту работу.

Опции `oneline` и `format` являются особенно полезными с опцией `--graph` команды `log`. С этой опцией вы сможете увидеть небольшой граф в формате ASCII, который показывает текущую ветку и историю слияний.
```git
git log --pretty=format:"%h %s" --graph
* 2d3acf9 Ignore errors from SIGCHLD on trap
*  5e3ee11 Merge branch 'master' of git://github.com/dustin/grit
|\
| * 420eac9 Add method for getting the current branch
* | 30e367c Timeout code and tests
* | 5a09431 Add timeout protection to grit
* | e1193f8 Support for heads with slashes in them
|/
* d6016bc Require time for xmlschema
*  11d191e Merge branch 'defunkt' into local
```

Мы рассмотрели только несколько простых опций для форматирования вывода с помощью команды `git log` — на самом деле их гораздо больше. Наиболее распространенные опции для команды `git log` содержит описание как уже рассмотренных, так и нескольких новых опций, которые могут быть полезными в зависимости от нужного формата вывода.

**Таблица 2.** Наиболее распространенные опции для команды `git log`

| Опция | Описание |
|-------|----------|  
| -p | Показывает патч для каждого коммита. |
| --stat | Показывает статистику измененных файлов для каждого коммита. |
| --shortstat | Отображает только строку с количеством изменений/вставок/удалений для команды `--stat`. |
| --name-only | Показывает список измененных файлов после информации о коммите. |
| --name-status | Показывает список файлов, которые добавлены/изменены/удалены. |
| --abbrev-commit | Показывает только несколько символов SHA-1 чек-суммы вместо всех 40. |
| --relative-date | Отображает дату в относительном формате (например, «2 weeks ago») вместо стандартного формата даты. |
| --graph | Отображает ASCII граф с ветвлениями и историей слияний. |
| --pretty | Показывает коммиты в альтернативном формате. Возможные варианты опций: `oneline`, `short`, `full`, `fuller` и `format` (с помощью последней можно указать свой формат). |
| --oneline | Сокращение для одновременного использования опций `--pretty=oneline --abbrev-commit`. |

### Ограничение вывода ###